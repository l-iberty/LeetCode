# 76. Minimum Window Substring

```cpp
class Solution {
public:
  string minWindow(string s, string t) {
    int l = 0, r = 0, left = 0, right = -1;
    int minWindowLen = INT32_MAX;

    for (char c : t) {
      counters[c]++;
    }

    while (r < s.size()) {
      windowCounters[s[r]]++;
      if (isValid()) {
        // minimize window
        while (windowCounters[s[l]] > counters[s[l]]) {
          windowCounters[s[l++]]--;
        }

        int len = r - l + 1;
        if (len < minWindowLen) {
          minWindowLen = len;
          right = r, left = l;
        }
      }
      r++;
    }

    return s.substr(left, right - left + 1);
  }

  bool isValid() {
    for (auto &pair : counters) {
      if (pair.second > windowCounters[pair.first]) {
        return false;
      }
    }
    return true;
  }
  
private:
  unordered_map<char, int> counters;
  unordered_map<char, int> windowCounters;
};
```

第二次做这个题的时候我很快就想到了算法，与官方给的思路一致, 上面那个代码是对算法的直接实现，每次都调用`isValid()`判断窗口是否有效，非常易懂，但其内部的循环增加了复杂度，使性能变差(耗时88ms)。我参照官方给的代码(官方的代码可读性很差，难以理解)降低复杂度，并优化到24ms：

```cpp
class Solution {
public:
  string minWindow(string s, string t) {
    int l = 0, r = 0, left = 0, right = -1;
    int minWindowLen = INT32_MAX;

    for (char c : t) {
      counters[c]++;
    }
    int required = counters.size();
    int formed = 0;

    while (r < s.size()) {
      char c = s[r];
      windowCounters[c]++;

      if (windowCounters[c] == counters[c]) {
        formed++;
      }

      if (formed == required) {
        // minimize window
        while (windowCounters[s[l]] > counters[s[l]]) {
          windowCounters[s[l++]]--;
        }

        int len = r - l + 1;
        if (len < minWindowLen) {
          minWindowLen = len;
          right = r, left = l;
        }
      }
      r++;
    }

    return s.substr(left, right - left + 1);
  }

private:
  unordered_map<char, int> counters;
  unordered_map<char, int> windowCounters;
};
```

以下是隔了一个月重做时写的：

```cpp
    string minWindow(string s, string t) {
      string res;
      int l = 0, r = 0, formed = 0, minLen = INT32_MAX;
      
      unordered_map<char, int> dict;
      unordered_map<char, int> windowCount;
      
      for (char c: t) {
        dict[c]++;
      }
      
      int required = dict.size();
      
      while (r < s.size()) {
        char c = s[r];
        windowCount[c]++;
        
        if (windowCount[c] == dict[c]) {
          formed++;
        }
        
        if (formed == required) {
          while (windowCount[s[l]] != dict[s[l]]) {
            windowCount[s[l]]--;
            l++;
          }
          
          int len = r - l + 1;
          if (len < minLen) {
            minLen = len;
            res = s.substr(l, len);
          }

          // 以下，移动 left 指针
          
          c = s[l++];
          windowCount[c]--;
          if (windowCount[c] < dict[c]) {
            formed--;
          }
          
          while (l <= r && dict.find(c) == dict.end()) {
            c = s[l++];
            windowCount[c]--;
          }
        }
        r++;
      }
      
      return res;
    }
```